### 面试题总结

* Activity生命周期: onCreate()—>onStart()—>onResume()，Activity进入运行状态

  ​				 onPause()—>onStop  onDestroy 

* 任务栈模式

  ​	standard : 标准模式 ,每次启动都会重新创建对象,加入任务栈

  ​	singleTop : 栈顶复用模式, 每次创建都会查看栈顶是否存在.

  ​	singleTask:栈内复用模式,创建会查看栈内是否存在,存在就会从栈内取,并移动栈顶,并清除掉前面所有的任务

  ​	singleInstance : 这种模式的Activity只能单独位于一个任务栈内,由于栈内复用的特性,后续请求均不会创建新的Activity,除非这个独特的任务栈被系统销毁了

* **广播(Broadcast Receiver)的两种动态注册和静态注册有什么区别。**

  - 静态注册：在AndroidManifest.xml文件中进行注册，当App退出后，Receiver仍然可以接收到广播并且进行相应的处理
  - 动态注册：在代码中动态注册，当App退出后，也就没办法再接受广播了

* **Android5.0、6.0新特性。**

  Android5.0新特性：

  - MaterialDesign设计风格
  - 支持多种设备
  - 支持64位ART虚拟机

  Android6.0新特性

  - 大量漂亮流畅的动画
  - 支持快速充电的切换
  - 支持文件夹拖拽应用
  - 相机新增专业模式

  Android7.0新特性

  - 分屏多任务
  - 增强的Java8语言模式
  - 夜间模式

* **AsyncTask使用**

  首先从Android3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出异常,这里面封装了两个线程池,一个是用于任务的排队,一个是执行任务,AsyncTask还有一个Handler，叫InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。一半配合自定义线程池的使用

  ​

* **1，ANR排错一般有三种类型**

  1. KeyDispatchTimeout（5秒） - 主要是类型按键或触摸事件在特定时间内无响应
  2. BroadcastTimeout（10秒）--BroadcastReceiver在特定时间内无法处理完成
  3. ServiceTimeout（20 secends） - 小概率事件服务在特定的时间内无法处理完成

  2，哪些操作会导致ANR在主线程执行以下操作：

  1. 高耗时的操作，如图像变换
  2. 磁盘读写，数据库读写操作
  3. 大量的创建新对象

  3，如何避免

  1. UI线程尽量只做跟UI相关的工作
  2. 耗时的操作（比如数据库操作，I / O，连接网络或者别的有可能阻塞UI线程的操作）把它放在单独的线程处理
  3. 尽量用处理器来处理UIThread和别的线程之间的交互

  5，如何排查

  1. 首先分析日志
  2. 从trace.txt文件查看调用堆栈，adb pull data / anr / traces.txt ./mytraces.txt
  3. 看代码
  4. 仔细查看ANR的成因（IOWAIT？方框？memoryleak？）



*    **TCP和UDP的区别**

     1.tcp是面向连接,udp是无连接,及发送数据前不需要建立连接

     2.tcp提供可靠的数据传输,无差错,无丢失,不重复,且按照顺序,udp不保证数据可靠交付

     3.tcp面向字节传输,udp面向报文,在网络拥堵的情况下任然不会降低传输的频率

     4.tcp是点对点传输,udp支持一对一,一对多,多对一交互

     5.tco首字母是20字节,udp是8个字节

*    **性能优化**

     1.避免重复创建对象

     2.静态优于抽象,对一些特定通用的方法

     3.常量前面加上static final

     4.使用增强For循环

     5.尽量使用系统的API

*    **内存优化**

     1.java内存分配有3快区域  静态存储区  栈(方法内的局部变量)  堆(对象实例)

     2.Gc机制:。Java中对象是采用new或者反射的方法创建的，这些对象的创建都是在堆（Heap）中分配的，所有对象的回收都是由Java虚拟机通过垃圾回收机制完成的。GC为了能够正确释放对象，会监控每个对象的运行状况，对他们的申请、引用、被引用、赋值等状况进行监控，Java会使用有向图的方法进行管理内存，实时监控对象是否可以达到，如果不可到达，则就将其回收，这样也可以消除引用循环的问题。在Java语言中，判断一个内存空间是否符合垃圾收集标准有两个：一个是给对象赋予了空值null，以下再没有调用过，另一个是给对象赋予了新值，这样重新分配了内存空间。

     3.造成内存泄露的原因:**各种连接,内部类和外部模块的引用,单例模式,Handler 造成的内存泄漏** 我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。

     4.在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。

     5.代码的抽取

     6.ui界面的渲染,是否渲染过渡,嵌套过多

     ​

*    **安全机制**

     1.进程沙箱隔离机制:应用程序在安装时会被赋予一个独特的用户标示,并永久保存,在虚拟机运行时会有一个独独立的进程.

     2.应用程序签名机制:APK必须被开发者赋予数字签名

     3.权限申明机制

     4.访问控制机制:确保系统文件和用户数据不受非法访问

*    **java加密**

     1.单向加密:不可逆加密 MD5,

     2.对称加密:加密和解密利用同一组秘钥,DES

     3.非对称加密:分为公钥和私钥,二者是非对称,就是用公钥加密需要用私钥解密,私钥加密需要公钥解密如DSA,,RSA

     4.URL防篡改  在参数列表多添加一个参数,把参数用一个bs64加密之后生成一个密钥在用单项加密生成一个值,添加到参数列表.

     5.APP加固 : 360加固宝,腾讯

*    **Https**

     https是由SSL + http协议构建的可进行加密传输,身份认证的网络协议,

     访问流程:  1.带上随机数访问服务器

     ​		   2.服务器更具客服端随机数返回一个随机数和公钥

     ​		   3.客户端更具服务端的随机数生成一个KEY和私钥,将KEY传递给服务器

     4. 服务器根据第一次收到的随机数和KEY按照相同的算法生成一个密钥,完成沟通

*    ### 购物流程

     - 进入商品详情页面
       - 加入购物车
         - 实现一个网络请求,把商品的一些信息提交到购物车的接口上
       - 立即购买
         - 携带一些关于商品的信息跳转到确认订单的界面,该页面需要提供收货人的信息,还可以修改购买的数量,这里需要做一些判断,(商品库存,非法数值)
         - 点击确认下单,跳转到支付页面
           - 微信支付
           - 支付宝支付
           - 支付后,会创建一笔订单,订单确认前后台会先去判断库存是否足够,库存不足则会提示用户,如果购买成功,库存则会做一些相应的操作

     ### 支付宝支付流程

     - 1）获取订单
       2）订单生成签名
       3）生成支付信息
       4）调起支付
       5）处理支付回调结果
       2.注册事项
       1）公私钥要在使用时不能出现空格
       2）签名和支付信息生成要正确
       3）禁止多次调用同一次支付

     ### 微信支付流程

     - 1.获取预支付id
       2.准备支付订单信息
       3.调起微信支付
       4.处理微信支付的结果

       2）注册事项
       1.使用正式的签名，调试的签名和创建应用的签名要正确
       2.处理支付结果的类的包名要正确

       ### 支付宝接入

       - 下载SDK,打开里面的.exe文件,会在该目录下生成两个pem文件,分别是公钥和私钥
       - 登陆支付宝的应用模块,把公钥填写进去
       - 在项目中添加一些权限
       - 怎么生成私钥跟密钥:
         - 下载完支付宝的支付SDK后打开里面的一个.exe文件,输入两串字符串后会在当前目录下生成两个pem文件,分别就是公钥和私钥
       - 生成订单信息:
         - 有个方法叫做getOrderInfo,然后传入商品的名称,商品的描述,商品的价钱

*    **MVP分析**

     好处:

     ​	1.降低代码耦合

     ​	2.模块职责划分明显,层次清晰

     ​	3.P层可以复用

     ​	4.利于单元测试

     ​	5.代码灵活性更强

     坏处:

     ​	1.P层除了业务逻辑以外还有很多View层和Model的同步操作,照成P层代码比较笨重,维护困难

     ​	2.由于视图渲染都在P层,所以视图和P层交互频繁

     ​	3.类过多.

     四个要素:

     1. View :负责绘制UI元素、与用户进行交互(在Android中体现为Activity);
     2. View interface :需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;
     3. Model :负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合);
     4. Presenter :作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。

     ​

*    **Hanlder分析**

     hanlder是用于线程之间传递消息,new Handler时会查找当前线程是否有looper,有就创建一个消息队列,没有就会抛出异常,当调用looper.loop时,looper就会开始一个死循环,不断从消息队列中去获取消息

*    **JAVA基础**

     算法:冒泡,选择,二分查找法

     集合:1.Arraylist:底层是一个数组,可自动扩容,有序,查找速度最快,但不利于添加和删除,线程不安全

     ​	2.LinkedList是基于双向循环链表,有序,线程不安全,插入和删除快,查找慢

     ​	3.HashMap是基于哈希表实现的，每一个元素都是一个key-value对，其内部通过单链表解决冲突问题，容 量不足（超过了阈值）时，同样会自动增长。线程不安全,有序,key不可重复,Valur可以

*    **Socket解析**

     即套接字，**是一个对 TCP / IP协议进行封装 的编程调用接口（API）**

     1. 即通过`Socket`，我们才能在Andorid平台上通过 `TCP/IP`协议进行开发
     2. `Socket`不是一种协议，而是一个编程调用接口（`API`），属于传输层（主要解决数据如何在网络中传输）

     成对出现，一对套接字：

     ​

*    **EventBus的使用**

     EventBus是一个针对Android的发布和订阅的事件总线,主要功能是替代Initent handlerz在Activity,fragmengt线程之间传递消息,

     ​

*    ### Picasso分析

     - 什么是Picasso:
       - Picasso是现在比较流行的一个图片加载框架
     - Picasso的优点:
       - 他可以解决我们在开发时遇到的诸多问题,比如说OOM,图片错位等,这些问题主要是在展示多张图片时所会遇到的
     - Picasso的功能:
       - resize:图片裁剪
       - pauseTag(tag) : 暂停加载
       - resumeTag(tag) : 恢复加载
       - ​
     - with方法使用了单例模式,返回一个Picasso实例,真正创建Picasso实例的代码是在build方法中实现的;
     - build:
       - Utils.createDefaultDownloader(context)
         - 使用反射查看我们是否集成了OkHttp,如果有就使用Okhttp创建一个下载器,否则就使用HttpUrlConnection创建下载器,也可以使用我们自己的下载器,这样就可以指定图片缓存的一个路径了
     - Picasso是使用它里面的一个内部类Builder来创建实例的,里面初始化了下载器,缓存类,线程池等,并且把这些对象都封装到了分发器Dispatcher,最后返回了一个Picasso对象
     - 接着通过load方法设置图片的加载源,可以是一个Uri地址,File文件,res资源,然后返回了一个RequestCreator对象
     - 通过RequestCreator对象调用其里面的into方法,into方法里面首先会先判断是否在主线程,再去检查我们传入的View是否存在,如果我们没有设置Uri,或者是Drawable,就会停止请求
     - Downloader